// <auto-generated>
// Generated by ProvisionData.HaloPSA.DtoGenerator
// Changes to this file will be overwritten on next generation.
// </auto-generated>

#nullable enable

namespace ProvisionData.HaloPSA.DTO;

/// <summary>
/// Custom fields implementation for Asset.
/// </summary>
public partial class Asset
{
    #region Custom Fields - Static Initialization

    private static readonly Lock MappingLock = new();
    private static volatile Boolean Mapped;
    private static Int32 ModelFieldId;
    private static Int32 NameFieldId;
    private static Int32 PurchaseDateFieldId;
    private static Int32 SerialNumberFieldId;
    private static Int32 UserFieldId;

    /// <summary>
    /// Applies field mappings from the provided configuration.
    /// This method is thread-safe and will only execute once.
    /// </summary>
    /// <param name="provider">The field mapping provider containing configuration.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown when required field mappings are not configured.
    /// </exception>
    /// <remarks>
    /// <para>This method uses double-checked locking for thread safety.</para>
    /// <para>Required fields: Model, SerialNumber</para>
    /// </remarks>
    public static void ApplyFieldMappings(IFieldMappingProvider provider)
    {
        if (!Mapped)
        {
            lock (MappingLock)
            {
                if (!Mapped)
                {
                    ModelFieldId = provider.GetFieldId(nameof(Asset), nameof(Model));
                    NameFieldId = provider.GetFieldId(nameof(Asset), nameof(Name));
                    PurchaseDateFieldId = provider.GetFieldId(nameof(Asset), nameof(PurchaseDate));
                    SerialNumberFieldId = provider.GetFieldId(nameof(Asset), nameof(SerialNumber));
                    UserFieldId = provider.GetFieldId(nameof(Asset), nameof(User));

                    // Validate required field mappings
                    if (ModelFieldId == 0 || SerialNumberFieldId == 0)
                    {
                        throw new InvalidOperationException(
                            $"Required field mappings not configured for {nameof(Asset)}. " +
                            $"Check configuration section 'HaloPsaApiClient:FieldMappings:{nameof(Asset)}'. " +
                            $"Required fields: Model, SerialNumber");
                    }

                    Mapped = true;
                }
            }
        }
    }

    /// <inheritdoc/>
    public Boolean FieldsAreMapped => Mapped;

    /// <inheritdoc/>
    public void ApplyFieldMap(IFieldMappingProvider provider) => ApplyFieldMappings(provider);

    /// <inheritdoc/>
    public String ModelTypeName => nameof(Asset);

    /// <inheritdoc/>
    public IEnumerable<String>? FieldNames
        => [
            nameof(Model),
            nameof(Name),
            nameof(PurchaseDate),
            nameof(SerialNumber),
            nameof(User)
        ];

#if DEBUG
    /// <summary>
    /// Resets field mappings for testing purposes.
    /// Only available in DEBUG builds.
    /// </summary>
    /// <remarks>
    /// This method is intended for unit testing only. It allows tests to reset
    /// the static field mapping state between test runs.
    /// </remarks>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public static void ResetFieldMappingsForTesting()
    {
        lock (MappingLock)
        {
            Mapped = false;
            ModelFieldId = 0;
            NameFieldId = 0;
            PurchaseDateFieldId = 0;
            SerialNumberFieldId = 0;
            UserFieldId = 0;
        }
    }

    /// <summary>
    /// Gets current field mapping state for testing/debugging purposes.
    /// Only available in DEBUG builds.
    /// </summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public static IReadOnlyDictionary<String, Int32> GetCurrentFieldMappingsForTesting()
    {
        return new Dictionary<String, Int32>
        {
            [nameof(Model)] = ModelFieldId,
            [nameof(Name)] = NameFieldId,
            [nameof(PurchaseDate)] = PurchaseDateFieldId,
            [nameof(SerialNumber)] = SerialNumberFieldId,
            [nameof(User)] = UserFieldId
        };
    }
#endif

    #endregion

    #region Custom Field Properties

    /// <summary>
    /// Gets or sets the Model custom field.
    /// </summary>
    /// <remarks>
    /// The model identifier or name of the asset
    /// </remarks>
    [JsonIgnore]
    public String? Model
    {
        get => Fields.GetString(ModelFieldId);
        set => Fields.SetField(ModelFieldId, value);
    }

    /// <summary>
    /// Gets or sets the Name custom field.
    /// </summary>
    /// <remarks>
    /// The name or identifier of the asset
    /// </remarks>
    [JsonIgnore]
    public String? Name
    {
        get => Fields.GetString(NameFieldId);
        set => Fields.SetField(NameFieldId, value);
    }

    /// <summary>
    /// Gets or sets the PurchaseDate custom field.
    /// </summary>
    /// <remarks>
    /// The date the asset was purchased
    /// </remarks>
    [JsonIgnore]
    public DateTime? PurchaseDate
    {
        get => Fields.GetDateTime(PurchaseDateFieldId);
        set => Fields.SetField(this, PurchaseDateFieldId, value);
    }

    /// <summary>
    /// Gets or sets the SerialNumber custom field.
    /// </summary>
    /// <remarks>
    /// The hardware serial number of the asset
    /// </remarks>
    [JsonIgnore]
    public String? SerialNumber
    {
        get => Fields.GetString(SerialNumberFieldId);
        set => Fields.SetField(SerialNumberFieldId, value);
    }

    /// <summary>
    /// Gets or sets the User custom field.
    /// </summary>
    /// <remarks>
    /// The name of the user to whom this asset is assigned
    /// </remarks>
    [JsonIgnore]
    public String? User
    {
        get => Fields.GetString(UserFieldId);
        set => Fields.SetField(UserFieldId, value);
    }

    #endregion
}

#nullable restore
