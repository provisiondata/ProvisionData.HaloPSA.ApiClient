# Generator Extension: Custom Fields Implementation Guide

## Overview

This document outlines the implementation plan for extending the existing model generator to automatically generate custom field boilerplate code from configuration metadata.

## Goals

1. **Eliminate Copy-Paste Errors**: Generate all custom field boilerplate automatically
2. **Maintain Performance**: Keep static field initialization pattern
3. **Support Testing**: Include `#if DEBUG` reset methods
4. **Stay Focused**: Generator creates DTOs only, no test helpers
5. **Configuration-Driven**: Field definitions in `custom-fields-config.json`

---

## Configuration File Structure

### Location

```
src/ProvisionData.HaloPSA.ApiClient.Generator/custom-fields-config.json
```

### Schema

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "CustomFieldMappings": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "description": "Custom fields for a specific DTO type",
        "additionalProperties": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": ["string", "int32", "datetime", "boolean", "decimal"],
              "description": "C# type for the field"
            },
            "required": {
              "type": "boolean",
              "default": false,
              "description": "Whether this field must be configured"
            },
            "description": {
              "type": "string",
              "description": "XML documentation for the property"
            }
          },
          "required": ["type"]
        }
      }
    }
  }
}
```

### Example Configuration

```json
{
  "CustomFieldMappings": {
    "Asset": {
      "Name": {
        "type": "string",
        "required": true,
        "description": "Asset name"
      },
      "SerialNumber": {
        "type": "string",
        "required": true,
        "description": "Hardware serial number"
      },
      "User": {
        "type": "string",
        "required": false,
        "description": "Assigned user name"
      },
      "Model": {
        "type": "string",
        "required": false,
        "description": "Hardware model identifier"
      },
      "PurchaseDate": {
        "type": "datetime",
        "required": false,
        "description": "Date the asset was purchased"
      },
      "WarrantyExpiration": {
        "type": "datetime",
        "required": false,
        "description": "Date the warranty expires"
      },
      "Cost": {
        "type": "decimal",
        "required": false,
        "description": "Purchase cost of the asset"
      },
      "IsActive": {
        "type": "boolean",
        "required": false,
        "description": "Whether the asset is currently active"
      }
    },
    "Contact": {
      "Email": {
        "type": "string",
        "required": true,
        "description": "Primary email address"
      },
      "Phone": {
        "type": "string",
        "required": false,
        "description": "Primary phone number"
      },
      "Department": {
        "type": "string",
        "required": false,
        "description": "Department name"
      }
    },
    "Ticket": {
      "Priority": {
        "type": "int32",
        "required": false,
        "description": "Ticket priority level"
      },
      "EstimatedHours": {
        "type": "decimal",
        "required": false,
        "description": "Estimated hours to complete"
      }
    }
  }
}
```

---

## Generated Code Template

### File Naming Convention
```
{ModelName}.CustomFields.g.cs
```

Example: `Asset.CustomFields.g.cs`

### Generated Code Structure

```csharp
// <auto-generated>
// Generated by ProvisionData.HaloPSA.ApiClient.Generator
// Changes to this file will be overwritten on next generation.
// </auto-generated>

#nullable enable

namespace ProvisionData.HaloPSA.DTO;

/// <summary>
/// Custom fields implementation for {ModelName}.
/// </summary>
public partial class {ModelName} : IHasCustomFields
{
    #region Custom Fields - Static Initialization
    
    private static readonly Lock MappingLock = new();
    private static volatile Boolean Mapped;
    
    // Field ID declarations (one per custom field)
    private static Int32 {Field1Name}FieldId;
    private static Int32 {Field2Name}FieldId;
    // ... etc
    
    /// <summary>
    /// Applies field mappings from the provided configuration.
    /// This method is thread-safe and will only execute once.
    /// </summary>
    /// <param name="provider">The field mapping provider containing configuration.</param>
    /// <exception cref="InvalidOperationException">
    /// Thrown when required field mappings are not configured.
    /// </exception>
    /// <remarks>
    /// <para>This method uses double-checked locking for thread safety.</para>
    /// <para>Required fields: {list of required fields}</para>
    /// </remarks>
    public static void ApplyFieldMappings(IFieldMappingProvider provider)
    {
        if (!Mapped)
        {
            lock (MappingLock)
            {
                if (!Mapped)
                {
                    // Initialize all field IDs
                    {Field1Name}FieldId = provider.GetFieldId(nameof({ModelName}), nameof({Field1Name}));
                    {Field2Name}FieldId = provider.GetFieldId(nameof({ModelName}), nameof({Field2Name}));
                    // ... etc
                    
                    // Validate required field mappings
                    if ({RequiredField1}FieldId == 0 || {RequiredField2}FieldId == 0)
                    {
                        throw new InvalidOperationException(
                            $"Required field mappings not configured for {nameof({ModelName})}. " +
                            $"Check configuration section 'HaloPsaApiClient:FieldMappings:{nameof({ModelName})}'. " +
                            $"Required fields: {nameof({RequiredField1})}, {nameof({RequiredField2})}");
                    }
                    
                    Mapped = true;
                }
            }
        }
    }
    
    /// <inheritdoc/>
    public Boolean FieldsAreMapped => Mapped;
    
    /// <inheritdoc/>
    public void ApplyFieldMap(IFieldMappingProvider provider) => ApplyFieldMappings(provider);
    
    /// <inheritdoc/>
    public String ModelTypeName => nameof({ModelName});
    
    /// <inheritdoc/>
    public IEnumerable<String>? FieldNames
        => [
            nameof({Field1Name}),
            nameof({Field2Name}),
            // ... etc
        ];
    
#if DEBUG
    /// <summary>
    /// Resets field mappings for testing purposes.
    /// Only available in DEBUG builds.
    /// </summary>
    /// <remarks>
    /// This method is intended for unit testing only. It allows tests to reset
    /// the static field mapping state between test runs.
    /// </remarks>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public static void ResetFieldMappingsForTesting()
    {
        lock (MappingLock)
        {
            Mapped = false;
            {Field1Name}FieldId = 0;
            {Field2Name}FieldId = 0;
            // ... etc
        }
    }
    
    /// <summary>
    /// Gets current field mapping state for testing/debugging purposes.
    /// Only available in DEBUG builds.
    /// </summary>
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public static IReadOnlyDictionary<String, Int32> GetCurrentFieldMappingsForTesting()
    {
        return new Dictionary<String, Int32>
        {
            [nameof({Field1Name})] = {Field1Name}FieldId,
            [nameof({Field2Name})] = {Field2Name}FieldId,
            // ... etc
        };
    }
#endif
    
    #endregion
    
    #region Custom Field Properties
    
    /// <summary>
    /// Gets or sets the {Field1Name} custom field.
    /// </summary>
    /// <remarks>
    /// {Field1Description}
    /// </remarks>
    [JsonIgnore]
    public {Field1Type}? {Field1Name}
    {
        get => Fields.Get{TypeHelper}({Field1Name}FieldId);
        set => Fields.SetField({parameters based on type});
    }
    
    // ... etc for all fields
    
    #endregion
}

#nullable restore
```

---

## Type Mapping

The generator needs to map configuration types to C# types and appropriate extension methods:

| Config Type | C# Type | Getter Extension | Setter Extension | Notes |
|-------------|---------|------------------|------------------|-------|
| `string` | `String?` | `GetString(fieldId)` | `SetField(fieldId, value)` | Simple string |
| `int32` | `Int32?` | `GetInt32(fieldId)` | `SetField(fieldId, value?.ToString())` | Need to add GetInt32 extension |
| `datetime` | `DateTime?` | `GetDateTime(fieldId)` | `SetField(this, fieldId, value)` | Uses DTO overload |
| `boolean` | `Boolean?` | `GetBoolean(fieldId)` | `SetField(fieldId, value?.ToString())` | Need to add GetBoolean extension |
| `decimal` | `Decimal?` | `GetDecimal(fieldId)` | `SetField(fieldId, value?.ToString())` | Need to add GetDecimal extension |

### Required Extension Methods to Add

```csharp
// Add to FieldMappingExtensions in IHasCustomFields.cs

public static Boolean? GetBoolean(this IEnumerable<IdValue> fields, Int32 fieldId)
{
    if (fieldId == 0) return null;
    
    var value = fields.SingleOrDefault(f => f.Id == fieldId)?.Value;
    return Boolean.TryParse(value, out var result) ? result : null;
}

public static Decimal? GetDecimal(this IEnumerable<IdValue> fields, Int32 fieldId)
{
    if (fieldId == 0) return null;
    
    var value = fields.SingleOrDefault(f => f.Id == fieldId)?.Value;
    return Decimal.TryParse(value, CultureInfo.InvariantCulture, out var result) ? result : null;
}

// GetInt32 already exists but verify it's in the right place
```

---

## Generator Implementation Steps

### Phase 1: Configuration Loading

1. Add `custom-fields-config.json` to generator project
2. Create configuration model classes:
   ```csharp
   public class CustomFieldsConfiguration
   {
       public Dictionary<string, Dictionary<string, CustomFieldDefinition>> CustomFieldMappings { get; set; }
   }
   
   public class CustomFieldDefinition
   {
       public string Type { get; set; }
       public bool Required { get; set; }
       public string Description { get; set; }
   }
   ```
3. Load configuration in generator startup

### Phase 2: Template Generation

1. Create Scriban template: `CustomFields.scriban`
2. Add template data model:
   ```csharp
   public class CustomFieldsTemplateModel
   {
       public string ModelName { get; set; }
       public List<CustomFieldModel> Fields { get; set; }
       public List<string> RequiredFieldNames { get; set; }
   }
   
   public class CustomFieldModel
   {
       public string Name { get; set; }
       public string CSharpType { get; set; }
       public string GetterMethod { get; set; }
       public string SetterParameters { get; set; }
       public string Description { get; set; }
       public bool IsRequired { get; set; }
   }
   ```

### Phase 3: Integration with Existing Generator

1. Check if model has custom fields defined in config
2. If yes, generate `{ModelName}.CustomFields.g.cs` alongside existing `.g.cs` file
3. Ensure existing `{ModelName}.g.cs` includes `List<IdValue> Fields` property
4. Don't modify manually-created partial classes (like `Asset.cs`)

### Phase 4: Extension Methods

1. Add missing extension methods to `IHasCustomFields.cs`:
   - `GetBoolean`
   - `GetDecimal`
2. Ensure all type conversions handle `null` and invalid values gracefully

### Phase 5: Documentation

1. Generate XML comments for all properties
2. Include field descriptions from config
3. Document required vs optional fields
4. Add remarks about testing reset methods

---

## Usage After Generation

### For Library Developers

1. Update `custom-fields-config.json` with field definitions
2. Run generator
3. Review generated `*.CustomFields.g.cs` files
4. Write custom logic in manual partial classes (e.g., `Asset.cs`)

### For Library Consumers

1. Configure field mappings in `appsettings.json`:
   ```json
   {
     "HaloPsaApiClient": {
       "FieldMappings": {
         "Asset": {
           "Name": 101,
           "SerialNumber": 117,
           "User": 148,
           "Model": 51,
           "PurchaseDate": 24
         }
       }
     }
   }
   ```
2. Use DTOs naturally - mappings initialize on first API call
3. For unit tests, use `ResetFieldMappingsForTesting()` in DEBUG builds

---

## Testing Strategy

### Generator Tests

```csharp
[Fact]
public void Generator_WithCustomFieldsConfig_GeneratesCorrectFile()
{
    // Arrange
    var config = new CustomFieldsConfiguration { /* ... */ };
    
    // Act
    var result = generator.GenerateCustomFields("Asset", config);
    
    // Assert
    Assert.Contains("public partial class Asset : IHasCustomFields", result);
    Assert.Contains("private static Int32 NameFieldId;", result);
    Assert.Contains("ResetFieldMappingsForTesting", result);
}

[Fact]
public void Generator_WithRequiredFields_GeneratesValidation()
{
    // Arrange
    var config = new CustomFieldsConfiguration
    {
        CustomFieldMappings = new()
        {
            ["Asset"] = new()
            {
                ["Name"] = new() { Type = "string", Required = true }
            }
        }
    };
    
    // Act
    var result = generator.GenerateCustomFields("Asset", config);
    
    // Assert
    Assert.Contains("if (NameFieldId == 0)", result);
    Assert.Contains("Required fields: Name", result);
}
```

### DTO Tests (Using Generated Code)

```csharp
public class AssetCustomFieldsTests : IDisposable
{
    private readonly MockFieldMappingProvider _provider;
    
    public AssetCustomFieldsTests()
    {
        Asset.ResetFieldMappingsForTesting();
        _provider = new MockFieldMappingProvider();
        _provider.AddMapping("Asset", "Name", 101);
        _provider.AddMapping("Asset", "SerialNumber", 117);
    }
    
    [Fact]
    public void ApplyFieldMappings_WithValidConfig_InitializesCorrectly()
    {
        // Act
        Asset.ApplyFieldMappings(_provider);
        
        // Assert
        Assert.True(new Asset().FieldsAreMapped);
        var mappings = Asset.GetCurrentFieldMappingsForTesting();
        Assert.Equal(101, mappings["Name"]);
    }
    
    public void Dispose()
    {
        Asset.ResetFieldMappingsForTesting();
    }
}
```

---

## Migration Path (For Existing Code)

Since this is V1 and no migration support is needed:

1. Delete manually-written custom field code from existing DTOs
2. Add definitions to `custom-fields-config.json`
3. Regenerate
4. Keep any custom factory methods in manual partial classes

Example:
```
Before:
- Asset.cs (all custom field code + Create method)

After:
- Asset.CustomFields.g.cs (generated - all custom field boilerplate)
- Asset.cs (manual - just Create method and other custom logic)
```

---

## Error Handling

### Configuration Errors

```csharp
// Invalid type
throw new GeneratorException(
    $"Invalid custom field type '{fieldDef.Type}' for {modelName}.{fieldName}. " +
    $"Valid types: string, int32, datetime, boolean, decimal");

// Missing required configuration
throw new GeneratorException(
    $"Custom field definition missing required property 'type' for {modelName}.{fieldName}");
```

### Runtime Errors (Generated Code)

```csharp
// Missing required field mappings
throw new InvalidOperationException(
    $"Required field mappings not configured for {nameof(Asset)}. " +
    $"Check configuration section 'HaloPsaApiClient:FieldMappings:{nameof(Asset)}'. " +
    $"Required fields: Name, SerialNumber");
```

---

## Generator Project Changes

### Files to Add/Modify

```
src/ProvisionData.HaloPSA.ApiClient.Generator/
├── custom-fields-config.json (NEW)
├── Models/
│   ├── CustomFieldsConfiguration.cs (NEW)
│   └── CustomFieldDefinition.cs (NEW)
├── Templates/
│   └── CustomFields.scriban (NEW)
├── Generators/
│   └── CustomFieldsGenerator.cs (NEW)
└── Program.cs (MODIFY - integrate new generator)
```

### Dependencies

Ensure the generator project has:
- Scriban (for templating) - already installed?
- System.Text.Json (for config loading)

---

## Acceptance Criteria

✅ Generator reads `custom-fields-config.json`  
✅ Generates `*.CustomFields.g.cs` files with correct structure  
✅ All field types (string, int32, datetime, boolean, decimal) supported  
✅ Required field validation generated correctly  
✅ `#if DEBUG` reset methods included  
✅ XML documentation generated from field descriptions  
✅ Thread-safe static initialization pattern maintained  
✅ `IHasCustomFields` interface implemented  
✅ Missing extension methods added to `FieldMappingExtensions`  
✅ Generator tests validate output  
✅ Integration tests prove DTOs work end-to-end  

---

## Next Steps

1. Review this implementation guide
2. Create `custom-fields-config.json` with initial Asset, Contact, Ticket definitions
3. Implement generator changes
4. Add missing extension methods
5. Generate and test with existing DTOs
6. Update README with usage instructions

---

## Questions?

Before implementation begins, verify:
- [ ] Configuration file structure is acceptable
- [ ] Generated code template matches expectations
- [ ] Type mapping is sufficient for HaloPSA use cases
- [ ] Testing strategy aligns with project practices
- [ ] File naming conventions are clear
